package com.raks.raksanalyzer.license;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

// JSON parsing
import com.fasterxml.jackson.databind.ObjectMapper;

public class LicenseValidator {

    // HARDCODED PUBLIC KEY (Generated by rakslicensemanager)
    // REPLACE THIS WITH THE ACTUAL KEY FROM STEP 495
    private static final String PUBLIC_KEY_BASE64 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyOxwxoMcVkHOufzgt7Gf" +
            "BlZa3/c/TqOr08VafwNEhthZy9C5hcPzceAS6c57qKuQSlu6w6bEjN6OHguf6XWU" +
            "u0htVRLSEfvqifOWm80KdGDqV7tvUmkUCv988s4EdsNdbiXFmYk+JcZMyoWQaJQn" +
            "cLR8eEfsnXeaPqA8Mt70PQ/g1PXOi8YMpURBHmWEKioGyIFdpNVUA495vOnHPznT" +
            "LmhZSMu2KujFK5gm4oIyZO0F16JgrcTujrqkzPw8TPx7OGIYeC+3FVFi6Y1pSoU4" +
            "xmWf7EhPhgbbBO3j6tg6DMbFRRNjyjyuhFNT6wQ757/CEq+Wc0zpk1gdn7ms3VMk" +
            "/wIDAQAB"; 

    public static void validate(String licenseKey) {
        // Check for license protection marker
        if (!new java.io.File("LICENSE_MODE_ENABLED").exists()) {
            return; // Bypass validation if marker is missing
        }

        if (licenseKey == null || licenseKey.trim().isEmpty()) {
            throw new SecurityException("License key is missing.");
        }

        try {
            // Split Payload and Signature
            String[] parts = licenseKey.split("\\.");
            if (parts.length != 2) {
                throw new SecurityException("Invalid license format.");
            }

            String payloadBase64 = parts[0];
            String signatureBase64 = parts[1];

            // 1. Verify Signature
            if (!verifySignature(payloadBase64, signatureBase64)) {
                throw new SecurityException("Invalid license signature. Tampering detected.");
            }

            // 2. Decode Payload
            String jsonPayload = new String(Base64.getDecoder().decode(payloadBase64), StandardCharsets.UTF_8);
            ObjectMapper mapper = new ObjectMapper();
            Map<String, String> data = mapper.readValue(jsonPayload, Map.class);

            // 3. Check Expiry
            String expiryDateStr = data.get("expiry");
            LocalDate expiryDate = LocalDate.parse(expiryDateStr);

            if (expiryDate.isBefore(LocalDate.now())) {
                String msg = "\n=======================================================\n" +
                             "   LICENSE EXPIRED\n" +
                             "=======================================================\n" +
                             "Your license for this application expired on: " + expiryDateStr + "\n\n" +
                             "To renew your access, please contact:\n" +
                             "   Rakesh Kumar\n" +
                             "   Email: rakesh.kumar@ibm.com\n" +
                             "          raksjnu@gmail.com\n" +
                             "=======================================================";
                throw new SecurityException(msg);
            }

            // Success (Silent)
            // System.out.println("License valid for: " + data.get("client"));

        } catch (SecurityException e) {
            throw e;
        } catch (Exception e) {
            throw new SecurityException("License validation error: " + e.getMessage());
        }
    }

    private static boolean verifySignature(String payloadBase64, String signatureBase64) throws Exception {
        byte[] keyBytes = Base64.getDecoder().decode(PUBLIC_KEY_BASE64);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
        KeyFactory kf = KeyFactory.getInstance("RSA");
        PublicKey publicKey = kf.generatePublic(spec);

        Signature publicSignature = Signature.getInstance("SHA256withRSA");
        publicSignature.initVerify(publicKey);
        publicSignature.update(payloadBase64.getBytes(StandardCharsets.UTF_8));

        byte[] signatureBytes = Base64.getDecoder().decode(signatureBase64);
        return publicSignature.verify(signatureBytes);
    }
}
